name: Build and Deploy to EC2

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

env:
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  REPOSITORY_NAME: ominx
  VERSION: ${{ github.sha }}

jobs:
  build:
    name: Build and Push das imagens Docker
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push API Gateway image
        run: |
          docker build -f ./apps/api-gateway/Dockerfile \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:${{ env.VERSION }} \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:latest \
            .
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:${{ env.VERSION }}
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:latest

      - name: Build and push Auth Service image
        run: |
          docker build -f ./apps/auth-service/Dockerfile \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:${{ env.VERSION }} \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:latest \
            .
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:${{ env.VERSION }}
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:latest

      - name: Build and push User UI image
        run: |
          docker build -f ./apps/user-ui/Dockerfile \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:${{ env.VERSION }} \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:latest \
            .
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:${{ env.VERSION }}
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:latest

      - name: Create deployment info
        run: |
          echo "API_GATEWAY_IMAGE=${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:${{ env.VERSION }}" >> $GITHUB_ENV
          echo "AUTH_SERVICE_IMAGE=${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:${{ env.VERSION }}" >> $GITHUB_ENV
          echo "USER_UI_IMAGE=${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:${{ env.VERSION }}" >> $GITHUB_ENV
          echo "DEPLOYMENT_TIME=$(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info
          path: |
            docker-compose.prod.yml
            infra/nginx/ominx.conf
          retention-days: 30

  deploy:
    name: Deploy na EC2
    runs-on: self-hosted
    needs: build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'

    environment: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker (User e Grupo)
        run: |
          sudo systemctl start docker
          sudo usermod -aG docker $USER

          # Verificar se Docker está funcionando
          docker info
          docker version

          # Verificar se o usuário está no grupo docker
          groups $USER

      - name: Criando .env
        run: |
          cat > .env << EOF
          # Configurações JWT
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}

          # Configurações do Frontend
          NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_AUTH_URL=${{ secrets.NEXT_PUBLIC_AUTH_URL }}

          # Configurações para EC2/AWS
          EC2_PUBLIC_IP=${{ secrets.EC2_PUBLIC_IP }}
          DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}

          # Configurações do Servidor
          HOST=0.0.0.0
          PORT=8080
          NODE_ENV=production
          EOF

      - name: Stop any existing containers
        run: |
          # Parar containers que possam estar usando as portas
          docker stop $(docker ps -q) || true
          docker rm $(docker ps -aq) || true

          # Parar serviços do sistema que possam estar usando as portas
          sudo systemctl stop nginx || true
          sudo systemctl disable nginx || true

      - name: Clean up Docker resources
        run: |
          # Clean up any remaining containers
          docker stop $(docker ps -q) || true
          docker rm $(docker ps -aq) || true

      - name: Remove existing images
        run: |
          # Remove all images to ensure clean state
          docker rmi $(docker images -q) || true
          docker system prune -a -f

      - name: Pull new images
        run: |
          # Pull the new images
          docker pull devicaro18/ominx-api-gateway:${{ env.VERSION }}
          docker pull devicaro18/ominx-auth-service:${{ env.VERSION }}
          docker pull devicaro18/ominx-user-ui:${{ env.VERSION }}

      - name: Setup Kubernetes
        run: |
          # Parar Minikube se estiver rodando
          minikube stop || true
          minikube delete || true

          # Iniciar Minikube com driver docker (mais simples)
          minikube start --driver=docker --force

          # Verificar status do Kubernetes
          kubectl cluster-info
          kubectl get nodes

      - name: Setup Ingress Controller
        run: |
          # Configurar Ingress Controller
          chmod +x infra/scripts/setup-ingress.sh
          ./infra/scripts/setup-ingress.sh

      - name: Deploy to Kubernetes
        run: |
          # Aplicar namespace
          kubectl create namespace ecommerce --dry-run=client -o yaml | kubectl apply -f -

          # Aplicar ConfigMap
          kubectl apply -f infra/k8s/configmap.yaml

          # Aplicar deployments
          kubectl apply -f infra/k8s/api-gateway-deployment.yaml
          kubectl apply -f infra/k8s/auth-service-deployment.yaml
          kubectl apply -f infra/k8s/user-ui-deployment.yaml

          # Aplicar ingress
          kubectl apply -f infra/k8s/ingress.yaml

          # Atualizar imagens nos deployments
          kubectl set image deployment/api-gateway api-gateway=devicaro18/ominx-api-gateway:${{ env.VERSION }} -n ecommerce
          kubectl set image deployment/auth-service auth-service=devicaro18/ominx-auth-service:${{ env.VERSION }} -n ecommerce
          kubectl set image deployment/user-ui user-ui=devicaro18/ominx-user-ui:${{ env.VERSION }} -n ecommerce

          # Aguardar rollout
          echo "Waiting for deployments to be ready..."
          kubectl rollout status deployment/api-gateway -n ecommerce --timeout=300s
          kubectl rollout status deployment/auth-service -n ecommerce --timeout=300s
          kubectl rollout status deployment/user-ui -n ecommerce --timeout=300s

      - name: Wait for services to be ready
        run: |
          echo "Waiting for services to be ready..."
          sleep 30

          # Verificar status dos pods
          echo "=== Pods Status ==="
          kubectl get pods -n ecommerce

          # Verificar status dos serviços
          echo "=== Services Status ==="
          kubectl get services -n ecommerce

          # Verificar status do ingress
          echo "=== Ingress Status ==="
          kubectl get ingress -n ecommerce

          # Health check com retry
          echo "Performing health checks..."
          MINIKUBE_IP=$(minikube ip)

          # Adicionar hosts temporariamente para teste
          echo "$MINIKUBE_IP api.ecommerce.local" | sudo tee -a /etc/hosts
          echo "$MINIKUBE_IP auth.ecommerce.local" | sudo tee -a /etc/hosts
          echo "$MINIKUBE_IP ecommerce.local" | sudo tee -a /etc/hosts

          for i in {1..5}; do
            echo "Attempt $i of 5"
            if curl -f http://ecommerce.local/health && curl -f http://api.ecommerce.local/ && curl -f http://auth.ecommerce.local/; then
              echo "Health checks passed!"
              break
            else
              echo "Health checks failed, waiting 10 seconds..."
              sleep 10
            fi
          done

          # Final health check
          curl -f http://ecommerce.local/health || (echo "Health check failed" && exit 1)

      - name: Cleanup old images and containers
        run: |
          # Remove all stopped containers
          docker container prune -f

          # Remove all unused images
          docker image prune -a -f

          # Remove all unused networks
          docker network prune -f

          # Remove all unused volumes
          docker volume prune -f

          # Full system cleanup
          docker system prune -a -f

      - name: Send deployment notification
        run: |
          MINIKUBE_IP=$(sudo minikube ip)
          echo "Deploy finalizado com Sucesso!!"
          echo "Main URL: http://$MINIKUBE_IP"
          echo "API Gateway: http://$MINIKUBE_IP/api/"
          echo "Auth Service: http://$MINIKUBE_IP/auth/"
          echo "Version: ${{ env.VERSION }}"
          echo "Deployed at: ${{ env.DEPLOYMENT_TIME }}"
          echo "Minikube IP: $MINIKUBE_IP"

      - name: Create deployment summary
        run: |
          MINIKUBE_IP=$(sudo minikube ip)
          cat > deployment-summary.md << EOF
          # Deployment Summary

          ## Deployment Information
          - **Version**: ${{ env.VERSION }}
          - **Deployed at**: ${{ env.DEPLOYMENT_TIME }}
          - **Environment**: ${{ github.event.inputs.environment || 'production' }}
          - **Minikube IP**: $MINIKUBE_IP

          ## Services
          - **API Gateway**: ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:${{ env.VERSION }}
          - **Auth Service**: ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:${{ env.VERSION }}
          - **User UI**: ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:${{ env.VERSION }}

          ## URLs
          - **Main**: http://$MINIKUBE_IP
          - **API Gateway**: http://$MINIKUBE_IP/api/
          - **Auth Service**: http://$MINIKUBE_IP/auth/
          - **Health Check**: http://$MINIKUBE_IP/health

          ## Kubernetes Resources
          - **Namespace**: ecommerce
          - **Pods**: 3 (api-gateway, auth-service, user-ui)
          - **Services**: 3 (ClusterIP)
          - **Ingress**: 1 (nginx)

          ## Health Check
          - API Gateway: Running
          - Auth Service: Running
          - User UI: Running
          - Ingress Controller: Running
          EOF

      - name: Upload deployment summary
        uses: actions/upload-artifact@v4
        with:
          name: deployment-summary
          path: deployment-summary.md
          retention-days: 30
