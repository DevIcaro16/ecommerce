name: Build and Deploy to EC2

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging

env:
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  REPOSITORY_NAME: ominx
  VERSION: ${{ github.sha }}

jobs:
  build:
    name: Build and Push das imagens Docker
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login no Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push API Gateway image
        run: |
          docker build -f ./apps/api-gateway/Dockerfile \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:${{ env.VERSION }} \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:latest \
            .
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:${{ env.VERSION }}
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:latest

      - name: Build and push Auth Service image
        run: |
          docker build -f ./apps/auth-service/Dockerfile \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:${{ env.VERSION }} \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:latest \
            .
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:${{ env.VERSION }}
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:latest

      - name: Build and push User UI image
        run: |
          docker build -f ./apps/user-ui/Dockerfile \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:${{ env.VERSION }} \
            -t ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:latest \
            .
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:${{ env.VERSION }}
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:latest

      - name: Create deployment info
        run: |
          echo "API_GATEWAY_IMAGE=${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:${{ env.VERSION }}" >> $GITHUB_ENV
          echo "AUTH_SERVICE_IMAGE=${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:${{ env.VERSION }}" >> $GITHUB_ENV
          echo "USER_UI_IMAGE=${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:${{ env.VERSION }}" >> $GITHUB_ENV
          echo "DEPLOYMENT_TIME=$(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info
          path: |
            docker-compose.prod.yml
            infra/nginx/ominx.conf
          retention-days: 30

  deploy:
    name: Deploy na EC2
    runs-on: self-hosted
    needs: build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'

    environment: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker (User e Grupo)
        run: |
          sudo systemctl start docker
          sudo usermod -aG docker $USER

          # Verificar se Docker está funcionando
          docker info
          docker version

          # Verificar se o usuário está no grupo docker
          groups $USER

      - name: Criando .env
        run: |
          cat > .env << EOF
          # Configurações JWT
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}

          # Configurações do Frontend
          NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_AUTH_URL=${{ secrets.NEXT_PUBLIC_AUTH_URL }}

          # Configurações para EC2/AWS
          EC2_PUBLIC_IP=${{ secrets.EC2_PUBLIC_IP }}
          DOMAIN_NAME=${{ secrets.DOMAIN_NAME }}

          # Configurações do Servidor
          HOST=0.0.0.0
          PORT=8080
          NODE_ENV=production
          EOF

      - name: Stop any existing containers
        run: |
          # Parar containers que possam estar usando as portas
          docker stop $(docker ps -q) || true
          docker rm $(docker ps -aq) || true

          # Parar serviços do sistema que possam estar usando as portas
          sudo systemctl stop nginx || true
          sudo systemctl disable nginx || true

      - name: Clean up Docker resources
        run: |
          # Clean up any remaining containers
          docker stop $(docker ps -q) || true
          docker rm $(docker ps -aq) || true

      - name: Remove existing images
        run: |
          # Remove all images to ensure clean state
          docker rmi $(docker images -q) || true
          docker system prune -a -f

      - name: Pull new images
        run: |
          # Pull the new images
          docker pull devicaro18/ominx-api-gateway:${{ env.VERSION }}
          docker pull devicaro18/ominx-auth-service:${{ env.VERSION }}
          docker pull devicaro18/ominx-user-ui:${{ env.VERSION }}

      - name: Setup Kubernetes
        run: |
          # Verificar se Minikube já está rodando
          if minikube status &> /dev/null; then
            echo "Minikube já está rodando. Verificando status..."
            minikube status
          else
            echo "Iniciando Minikube..."
            minikube start --driver=docker --force
          fi

          # Verificar status do Kubernetes
          kubectl cluster-info
          kubectl get nodes

          # Verificar se o namespace já existe
          if kubectl get namespace ecommerce &> /dev/null; then
            echo "Namespace 'ecommerce' já existe"
          else
            echo "Criando namespace 'ecommerce'..."
            kubectl create namespace ecommerce
          fi

      - name: Setup Ingress Controller
        run: |
          # Configurar Ingress Controller
          chmod +x infra/scripts/setup-ingress.sh
          ./infra/scripts/setup-ingress.sh

      - name: Deploy to Kubernetes
        run: |
          # Verificar deployments existentes
          echo "Verificando deployments existentes..."
          kubectl get deployments -n ecommerce || echo "Nenhum deployment encontrado"

          # Aplicar ConfigMap (sempre atualizar)
          echo "Aplicando ConfigMap..."
          kubectl apply -f infra/k8s/configmap.yaml

          # Aplicar deployments com estratégia de atualização
          echo "Aplicando deployments..."
          kubectl apply -f infra/k8s/api-gateway-deployment.yaml
          kubectl apply -f infra/k8s/auth-service-deployment.yaml
          kubectl apply -f infra/k8s/user-ui-deployment.yaml

          # Aplicar ingress
          echo "Aplicando ingress..."
          kubectl apply -f infra/k8s/ingress.yaml

          # Atualizar imagens nos deployments existentes
          echo "Atualizando imagens dos deployments..."
          kubectl set image deployment/api-gateway api-gateway=devicaro18/ominx-api-gateway:${{ env.VERSION }} -n ecommerce --record
          kubectl set image deployment/auth-service auth-service=devicaro18/ominx-auth-service:${{ env.VERSION }} -n ecommerce --record
          kubectl set image deployment/user-ui user-ui=devicaro18/ominx-user-ui:${{ env.VERSION }} -n ecommerce --record

          # Aguardar rollout com retry
          echo "Aguardando rollouts..."
          for deployment in api-gateway auth-service user-ui; do
            echo "Aguardando rollout do deployment: $deployment"
            kubectl rollout status deployment/$deployment -n ecommerce --timeout=300s || {
              echo "Rollout falhou para $deployment. Verificando status..."
              kubectl describe deployment $deployment -n ecommerce
              kubectl get pods -n ecommerce -l app=$deployment
              exit 1
            }
          done

          # Verificar se todos os pods estão prontos
          echo "Verificando status dos pods..."
          kubectl get pods -n ecommerce

      - name: Wait for services to be ready
        run: |
          echo "Aguardando serviços ficarem prontos..."
          sleep 30

          # Verificar status dos pods
          echo "=== Status dos Pods ==="
          kubectl get pods -n ecommerce

          # Verificar status dos serviços
          echo "=== Status dos Serviços ==="
          kubectl get services -n ecommerce

          # Verificar status do ingress
          echo "=== Status do Ingress ==="
          kubectl get ingress -n ecommerce

          # Health check com NodePort (mais confiável)
          echo "Realizando health checks via NodePort..."
          MINIKUBE_IP=$(minikube ip)

          # Health check via NodePort
          for i in {1..5}; do
            echo "Tentativa $i de 5"
            
            # Testar via NodePort
            if curl -f http://localhost:30080/ && \
               curl -f http://localhost:30061/ && \
               curl -f http://localhost:30301/; then
              echo "Health checks via NodePort passaram!"
              break
            else
              echo "Health checks falharam, aguardando 10 segundos..."
              sleep 10
            fi
          done

          # Health check final via NodePort
          echo "Health check final via NodePort..."
          curl -f http://localhost:30080/ || (echo "API Gateway health check failed" && exit 1)
          curl -f http://localhost:30061/ || (echo "Auth Service health check failed" && exit 1)
          curl -f http://localhost:30301/ || (echo "User UI health check failed" && exit 1)

          echo "Todos os health checks passaram!"

      - name: Cleanup old images and containers
        run: |
          # Remove all stopped containers
          docker container prune -f

          # Remove all unused images
          docker image prune -a -f

          # Remove all unused networks
          docker network prune -f

          # Remove all unused volumes
          docker volume prune -f

          # Full system cleanup
          docker system prune -a -f

      - name: Send deployment notification
        run: |
          MINIKUBE_IP=$(minikube ip)
          echo "🚀 Deploy finalizado com Sucesso!!"
          echo "📊 Version: ${{ env.VERSION }}"
          echo "⏰ Deployed at: ${{ env.DEPLOYMENT_TIME }}"
          echo "🌐 Minikube IP: $MINIKUBE_IP"
          echo ""
          echo "🔗 URLs de Acesso (NodePort):"
          echo "   API Gateway: http://localhost:38080"
          echo "   Auth Service: http://localhost:36001"
          echo "   User UI: http://localhost:33001"
          echo ""
          echo "🔗 URLs de Acesso (Ingress):"
          echo "   API Gateway: http://api.ecommerce.local"
          echo "   Auth Service: http://auth.ecommerce.local"
          echo "   User UI: http://ecommerce.local"

      - name: Create deployment summary
        run: |
          MINIKUBE_IP=$(minikube ip)
          cat > deployment-summary.md << EOF
          # Deployment Summary

          ## Deployment Information
          - **Version**: ${{ env.VERSION }}
          - **Deployed at**: ${{ env.DEPLOYMENT_TIME }}
          - **Environment**: ${{ github.event.inputs.environment || 'production' }}
          - **Minikube IP**: $MINIKUBE_IP

          ## Services
          - **API Gateway**: ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-api-gateway:${{ env.VERSION }}
          - **Auth Service**: ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-auth-service:${{ env.VERSION }}
          - **User UI**: ${{ secrets.DOCKER_USERNAME }}/${{ env.REPOSITORY_NAME }}-user-ui:${{ env.VERSION }}

          ## URLs de Acesso
          ### NodePort (Recomendado)
          - **API Gateway**: http://localhost:30080
          - **Auth Service**: http://localhost:30061
          - **User UI**: http://localhost:30301

          ### Ingress (Requer configuração de hosts)
          - **API Gateway**: http://api.ecommerce.local
          - **Auth Service**: http://auth.ecommerce.local
          - **User UI**: http://ecommerce.local

          ## Kubernetes Resources
          - **Namespace**: ecommerce
          - **Pods**: 3 (api-gateway, auth-service, user-ui)
          - **Services**: 3 (NodePort)
          - **Ingress**: 1 (nginx)

          ## Health Check Status
          - API Gateway: ✅ Running (NodePort: 30080)
          - Auth Service: ✅ Running (NodePort: 30061)
          - User UI: ✅ Running (NodePort: 30301)
          - Ingress Controller: ✅ Running

          ## Rollout Strategy
          - **Update Strategy**: Rolling Update
          - **Max Unavailable**: 25%
          - **Max Surge**: 25%
          - **Image Update**: Automatic via kubectl set image
          EOF

      - name: Upload deployment summary
        uses: actions/upload-artifact@v4
        with:
          name: deployment-summary
          path: deployment-summary.md
          retention-days: 30
